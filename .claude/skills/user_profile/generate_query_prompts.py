#!/usr/bin/env python3
"""
Generate Query Prompts Script (User-Centric Version)
Implements Step 4.1 of the User Profile Manager workflow.
Logic:
1. Load Step 3 match results (match_[USER_ID].json).
2. For each product, take the Top 3 selected attributes and category.
3. Construct a natural language query generation prompt with semantic transformation rules.
4. Save consolidated prompts per user.
"""

import json
import os
import argparse
from datetime import datetime

def log_with_timestamp(message):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {message}")

def generate_query_prompt(asin, category, attributes):
    attr_list = "\n".join([f"{i+1}. {attr}" for i, attr in enumerate(attributes)])
    prompt = f"""You are a shopper looking for a [ {category} ] product on Amazon.

**Product Attributes (MUST include ALL 3):**
{attr_list}

**Task:**
Generate a natural, human-like search query based on these attributes.

**CRITICAL Requirements:**
1. **MUST include ALL 3 attributes** - Do not skip any attribute.
2. **Semantic Transformation Required**:
   - DO NOT copy-paste attributes directly
   - Transform attributes into natural shopping language
   - Example: "Long-lasting/Durable" → "lasts a long time" or "won't wear out"
   - Example: "High pigment concentration" → "rich colors that cover well"
   - Example: "Compact packaging" → "easy to carry around" or "fits in my bag"
3. **Length**: Exactly 25-30 words (count words, not characters). 
4. **Perspective**: First person natural tone (e.g., "I need...", "Looking for...").
5. **Human Generation Required**: Each query must be manually generated by reading the prompt and applying semantic transformation.

**Output Format:**
Output ONLY the polished query text. No explanations, no prefixes, no extra punctuation.

**Example Transformation:**
Attributes: ["Pearlescent shimmer", "Long-lasting/Durable", "High pigment concentration"]
❌ Bad: "fabric paint with pearlescent shimmer long-lasting durable high pigment concentration"
✅ Good: "I need fabric paint that shimmers and lasts through many projects with rich concentrated colors for my crafts"
"""
    return prompt

def main():
    parser = argparse.ArgumentParser(description="Generate Step 4 Query Prompts from Step 3 Match Results")
    parser.add_argument("--input", required=True, help="Path to match_[USER_ID].json")
    parser.add_argument("--output-dir", default="/home/wlia0047/ar57/wenyu/result/user_profile/query_prompts", help="Output directory")
    args = parser.parse_args()
    
    os.makedirs(args.output_dir, exist_ok=True)
    
    if not os.path.exists(args.input):
        log_with_timestamp(f"❌ Input file not found: {args.input}")
        return

    with open(args.input, 'r', encoding='utf-8') as f:
        data = json.load(f)
        user_id = data.get('user_id')
        results = data.get('results', [])

    if not user_id:
        log_with_timestamp("❌ User ID not found in input file.")
        return

    log_with_timestamp(f"Generating query prompts for user {user_id} ({len(results)} products)...")

    prompts_data = []
    for item in results:
        asin = item.get('asin')
        category = item.get('category', 'Unknown')
        attributes = item.get('selected_attributes', [])
        
        if not asin or len(attributes) < 1:
            continue
            
        # Ensure we have at most 3 attributes as per policy
        attributes = attributes[:3]
        
        prompt_text = generate_query_prompt(asin, category, attributes)
        prompts_data.append({
            "asin": asin,
            "prompt": prompt_text
        })

    output_file = os.path.join(args.output_dir, f"query_prompts_{user_id}.json")
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump({
            "user_id": user_id,
            "total_products": len(prompts_data),
            "prompts": prompts_data
        }, f, indent=2, ensure_ascii=False)
        
    log_with_timestamp(f"✅ Generated {len(prompts_data)} query prompts for user {user_id} -> {output_file}")

if __name__ == "__main__":
    main()
